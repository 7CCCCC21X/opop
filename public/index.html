<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8" />
  <title>Superchain æ‰¹é‡ç§¯åˆ†æŸ¥è¯¢</title>
  <style>
    body { font-family: sans-serif; max-width: 1000px; margin: auto; padding: 30px; }
    button, input, textarea { padding: 10px; font-size: 14px; margin: 5px 0; }
    textarea { width: 100%; height: 120px; }
    progress { width: 100%; height: 20px; }
    table { width: 100%; margin-top: 20px; border-collapse: collapse; }
    th, td { border: 1px solid #ccc; padding: 8px; text-align: center; }
    th { background: #f0f0f0; }
    #status, #lastUpdate { margin-top: 10px; font-size: 14px; color: #555; }
    #loading { display: none; font-weight: bold; color: green; margin-top: 10px; }
  </style>
</head>
<body>

  <h2>Superchain Leaderboard æŸ¥è¯¢å·¥å…·</h2>

  <button onclick="updateData()">ğŸ” æ›´æ–°æ•°æ®ï¼ˆ1-2000 é¡µï¼‰</button>
  <progress id="progress" value="0" max="2000"></progress>
  <div id="loading">â³ æ­£åœ¨åŠ è½½ä¸­...</div>
  <div id="status">æœªå¼€å§‹</div>
  <div id="lastUpdate"></div>

  <h3>æ‰¹é‡æŸ¥è¯¢åœ°å€</h3>
  <textarea id="searchInput" placeholder="æ¯è¡Œè¾“å…¥ä¸€ä¸ªåœ°å€ï¼ˆæ”¯æŒæ¨¡ç³ŠåŒ¹é…ï¼‰"></textarea><br>
  <button onclick="searchAddress()">ğŸ” å¼€å§‹æŸ¥è¯¢</button>

  <table>
    <thead>
      <tr>
        <th>åœ°å€</th>
        <th>ç§¯åˆ†</th>
        <th>å¾½ç« æ•°</th>
        <th>SuperChain ID</th>
      </tr>
    </thead>
    <tbody id="resultBody"></tbody>
  </table>

  <script>
    const API_URL = "/api/leaderboard";
    const MAX_PAGE = 2000;
    const CONCURRENCY = 20;
    const RETRY_LIMIT = 3;
    let leaderboardData = [];

    function saveToCache(data) {
      const now = new Date().toISOString();
      localStorage.setItem("leaderboardData", JSON.stringify(data));
      localStorage.setItem("lastUpdate", now);
      updateLastUpdateUI(now);
    }

    function loadFromCache() {
      const cached = localStorage.getItem("leaderboardData");
      const time = localStorage.getItem("lastUpdate");
      if (cached) {
        leaderboardData = JSON.parse(cached);
        document.getElementById("status").innerText = `âœ… å·²åŠ è½½æœ¬åœ°ç¼“å­˜ï¼Œå…± ${leaderboardData.length} æ¡è®°å½•`;
        updateLastUpdateUI(time);
      }
    }

    function updateLastUpdateUI(time) {
      if (time) {
        const dt = new Date(time);
        document.getElementById("lastUpdate").innerText = `ğŸ•’ ä¸Šæ¬¡æ›´æ–°æ—¶é—´ï¼š${dt.toLocaleString()}`;
      }
    }

    function chunk(arr, size) {
      const chunks = [];
      for (let i = 0; i < arr.length; i += size) {
        chunks.push(arr.slice(i, i + size));
      }
      return chunks;
    }

    async function fetchWithRetry(page, retries = RETRY_LIMIT) {
      try {
        const res = await fetch(`${API_URL}?page=${page}`);
        const json = await res.json();
        return json.data || [];
      } catch (e) {
        if (retries > 0) {
          console.warn(`ç¬¬ ${page} é¡µè¯·æ±‚å¤±è´¥ï¼Œé‡è¯•ä¸­ (${RETRY_LIMIT - retries + 1})...`);
          await new Promise(r => setTimeout(r, 300)); // ç­‰å¾… 300ms å†è¯•
          return await fetchWithRetry(page, retries - 1);
        } else {
          console.error(`ç¬¬ ${page} é¡µè¯·æ±‚å¤±è´¥ï¼Œå·²è·³è¿‡`);
          return [];
        }
      }
    }

    async function updateData() {
      leaderboardData = [];
      const pages = Array.from({ length: MAX_PAGE }, (_, i) => i + 1);
      const chunks = chunk(pages, CONCURRENCY);
      const progress = document.getElementById("progress");
      const status = document.getElementById("status");
      const loading = document.getElementById("loading");

      let completed = 0;
      loading.style.display = "block";

      for (const group of chunks) {
        const promises = group.map(page => fetchWithRetry(page));
        const results = await Promise.all(promises);

        results.flat().forEach(item => {
          leaderboardData.push({
            address: item.superaccount,
            points: item.total_points,
            badges: item.total_badges,
            chain: item.superChainId
          });
        });

        completed += group.length;
        progress.value = completed;

        const percent = ((completed / MAX_PAGE) * 100).toFixed(1);
        status.innerText = `âœ… æ­£åœ¨æ›´æ–°ä¸­ï¼š${percent}%`;
      }

      saveToCache(leaderboardData);
      loading.style.display = "none";
      status.innerText = `âœ… æ•°æ®æ›´æ–°å®Œæˆ`;
    }

    function searchAddress() {
      const lines = document.getElementById("searchInput").value
        .trim()
        .split("\n")
        .map(l => l.trim().toLowerCase())
        .filter(Boolean);

      const tbody = document.getElementById("resultBody");
      tbody.innerHTML = "";

      if (!lines.length) return;

      let foundCount = 0;

      lines.forEach(query => {
        const result = leaderboardData.filter(entry => entry.address.toLowerCase().includes(query));

        if (result.length === 0) {
          const row = document.createElement("tr");
          row.innerHTML = `<td>${query}</td><td colspan="3">âŒ æœªæ‰¾åˆ°</td>`;
          tbody.appendChild(row);
        } else {
          result.forEach(entry => {
            const row = document.createElement("tr");
            row.innerHTML = `
              <td>${entry.address}</td>
              <td>${entry.points}</td>
              <td>${entry.badges}</td>
              <td>${entry.chain}</td>
            `;
            tbody.appendChild(row);
            foundCount++;
          });
        }
      });

      document.getElementById("status").innerText = `ğŸ” æŸ¥è¯¢å®Œæˆï¼ŒæˆåŠŸåŒ¹é… ${foundCount} æ¡åœ°å€`;
    }

    window.onload = loadFromCache;
  </script>

</body>
</html>
